/*
*
* SPDX-License-Identifier: BSD-3-Clause
*
* Copyright (c) 2016-2022, Arm Limited. All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
* - Redistributions of source code must retain the above copyright notice, this
*   list of conditions and the following disclaimer.
* - Redistributions in binary form must reproduce the above copyright notice, this
*    list of conditions and the following disclaimer in the documentation and/or
*    other materials provided with the distribution.
* - Neither the name of ARM nor the names of its contributors may be used to
*    endorse or promote products derived from this software without specific prior
*    written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

#ifndef __SW_MCFE_H__
#define __SW_MCFE_H__

#include "acamera_types.h"
#include "acamera_fw.h"
#include "acamera.h"
#include "system_log.h"
#include "system_spinlock.h"
#include "sw_mcfe_queue.h"

typedef void ( *notify_frame_done_func )( uint32_t ctx_id, void *pvt_data );
typedef void ( *start_frame_func )( uint32_t ctx_id, void *pvt_data );

#define ISP_CONFIG_SPACE_MAX_NUM ( 2 )

/* Various states possible for Ping/Pong configuration spaces */
typedef enum {
    CONFIG_STATE_IDLE,
    CONFIG_STATE_CONFIG_DMA_IN_PROGRESS,
    CONFIG_STATE_CONFIG_DMA_DONE,
    CONFIG_STATE_SCHEDULED,
    CONFIG_STATE_ACTIVE,
    CONFIG_STATE_MAX
} config_state_t;

/* MCFE events based on external inputs like interrupts */
typedef enum {
    MCFE_EVENT_NEW_FRAME,
    MCFE_EVENT_DMA_CONFIG_DONE,
    MCFE_EVENT_DMA_METERING_DONE,
    MCFE_EVENT_FRAME_START,
    MCFE_EVENT_FRAME_END,
    MCFE_EVENT_MAX
} mcfe_event_type_t;

/* Internal events generated by MCFE based on each external event. These events are then
   then sent and processed on each ping/pong configuration space, as needed. */
typedef enum {
    CONFIG_EVENT_EXTRACT_STATS,
    CONFIG_EVENT_PREPARE,
    CONFIG_EVENT_DMA_DONE,
    CONFIG_EVENT_SCHEDULE,
    CONFIG_EVENT_START,
    CONFIG_EVENT_RESET,
    CONFIG_EVENT_MAX
} config_event_type_t;

// Context types supported by MCFE
typedef enum {
    CONTEXT_TYPE_SENSOR_STREAM,
    CONTEXT_TYPE_M2M,
    CONTEXT_TYPE_REMOTE_SENSOR,
    CONTEXT_TYPE_MAX
} context_type_t;

/* Configuration data associated to each ping/pong space */
typedef struct {
    int32_t ctx_id;
    config_state_t state;
    mcfe_frame_t frame;
    int32_t last_ctx_id;
    uint8_t metering_collected;
    uint8_t metering_dma_completed;
    uint8_t config_dma_completed;
} config_data_t;

typedef struct _mcfe_info {
    acamera_firmware_t *fw;                      // Pointer to the acamera firmware context
    sys_spinlock context_lock;                   // spinlock to synchronize context data
    config_data_t cfg[ISP_CONFIG_SPACE_MAX_NUM]; // Configuration data associated to each ping/pong space
    uint8_t frames_scheduled;                    // Number of frames scheduled to be processed by ISP. Used to synchronize frames sent to ISP.
    uint8_t frames_prepared;                     // Number of frames whose configuration DMA is initiated. Used to identify when both ping/pong spaces are idle.
    uint8_t last_config_space_id;                // Last active configuration space ID

    // callback functions
    notify_frame_done_func frame_done_cb; // Handle to external driver's frame done callback (called from FE interrupt)
    start_frame_func start_frame_cb;      // Handle to external driver's frame start callback
} mcfe_info_t;

/**
 *   Initialize the MCFE module.
 *
 *   Initializes its internal variables and the MCFE queue.
 *
 *   @param  g_fw - pointer to the acamera firmware
 *
 *   @return 0 - success
 *          -1 - fail.
 */
int32_t sw_mcfe_init( acamera_firmware_t *g_fw );

/**
 *   Deinitialize the MCFE module.
 *
 *   Resets its internal variables and the MCFE queue.
 *
 *   @param  none
 *
 *   @return 0 - success
 *          -1 - fail.
 */
int32_t sw_mcfe_deinit( void );

/**
 *   API for external driver to register callbacks with MCFE
 *
 *   External driver calls this API to register its frame start and frame done callbacks with MCFE. These are later used by MCFE
 *   to notify the external driver whenever a frame is ready to schedule or has been processed by ISP.
 *
 *   @param  frame_done_cb - callback function for frame done notification
 *   @param  start_frame_cb - callback function for frame start notification
 *
 *   @return none
 */
void sw_mcfe_register( notify_frame_done_func frame_done_cb, start_frame_func start_frame_cb );

/**
 *   Handle interrupts from ISP.
 *
 *   Handle interrupts from ISP. Currently, it processes only frame start and frame end interrupts. If frame start,
 *   it copies the stats from the previous frame and also, prepares the next frame configuration in ISP, if its available.
 *   In frame end, it notifies external driver about the completition of a frame processing and schedules next frame
 *   to be processed by ISP.
 *
 *   @param  irq_event - Event id whether frame start or frame end
 *
 *   @return 0 - success
 *          -1 - fail.
 */
int32_t sw_mcfe_handle_interrupt( uint32_t irq_event );

/**
 *   API called by external driver whenever a new frame is available.
 *
 *   MCFE adds this new frame in its queue. If the ISP is idle (no pending frames to be processed), it schedules
 *   the frame immediately, prepares its context in ISP, and notifies external driver to start sending the frame.
 *
 *   @param  ctx_id - Context id of the input frame
 *   @param  ctx_type - Context type of the input frame
 *   @param  pvt_data - Private metadata associated to the input frame, maintained by external driver. This private data
 *                      is returned to the client in frame start and frame end callbacks for quick mapping.
 *
 *   @return 0 - success
 *          -1 - fail.
 */
int32_t sw_mcfe_notify_frame( uint32_t ctx_id, uint32_t ctx_type, void *pvt_data );

#endif // __SW_MCFE_H__
